#summary Overview of available CacheKeyGenerator implementations
#labels Featured
#sidebar TableOfContents

= Introduction =

Every method invocation advised by @Cacheable or @!TriggersRemove has to have a key generated for use when access the corresponding cache. The [http://ehcache-spring-annotations.googlecode.com/svn/site/current/apidocs/com/googlecode/ehcache/annotations/key/CacheKeyGenerator.html CacheKeyGenerator] interface defines the API for generating these keys.

= Provided Cache Key Generators =
||*HashCodeCacheKeyGenerator*|| The default key generator. Very similar to [http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html#deepHashCode(java.lang.Object%5B%5D) Arrays.deepHashCode] ||
||*StringCacheKeyGenerator*|| A nice human readable key generator. Simply uses [http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html#deepToString(java.lang.Object%5B%5D) Arrays.deepToString] ||
||*ListCacheKeyGenerator*|| Does a deep inspection converting arrays to Lists and returning an immutable List of the key arguments. Useful if complete assurance is required when doing key comparisons ||
||*MessageDigestCacheKeyGenerator*|| Does the same object graph traversal that HashCodeCacheKeyGenerator does but instead of accumulating the hash code in a long a [http://java.sun.com/j2se/1.5.0/docs/api/java/security/MessageDigest.html MessageDigest] is used to provide a secure hash with a significantly larger key space. ||
||*ReflectionHashCodeCacheKeyGenerator*|| Does the same object graph traversal than HashCodeCacheKeyGenerator does but uses reflection to generate a hash code for objects that don't implement hashCode ||

= Key Consistency =
All of the included cache key generators will generate keys that are consistent between JVM executions and safe for distribution between JVMs in a distributed/clustered caching environment. The exception to this is if the method arguments don't fulfill the contract of the !CacheKeyGenerator being used as many require correct implementation of hashCode, equals, and/or toString. 

= Common !CacheKeyGenerator Configuration =
All of the included [http://ehcache-spring-annotations.googlecode.com/svn/site/1.0.0/apidocs/com/googlecode/ehcache/annotations/key/CacheKeyGenerator.html CacheKeyGenerator] implementations extend [http://ehcache-spring-annotations.googlecode.com/svn/site/1.0.0/apidocs/com/googlecode/ehcache/annotations/key/AbstractCacheKeyGenerator.html AbstractCacheKeyGenerator] which provides the following common configuration options.

==== Check for Cycles ====
Default *false*: If true the key generator will track visited objects during recursion and if a cycle is detected handle it correctly. If false the exact behavior is undefined but many of the key generators will fail with StackOverflowError due to infinite recursion.

==== Include Method ====
Default *true*: If true the declaring class, method name and method return type are included in the generated cache key. The effect of this is that keys become scoped to the annotated method. Consider the following method definitions:
{{{
@Cacheable(cache="weatherCache")
public Weather getWeatherById(String locationId);

@Cacheable(cache="weatherCache")
public Weather getWeatherByZip(String zipCode);
}}}

If both of these methods are called with the argument "49931" and the include method property is true different cache keys will be created. If the include method property is false the keys would be the same and could result in a collision if different Weather objects exist for "49931" as the locationId versus "49931" as the zipCode.

==== Include Parameter Types ====
Default *true*: If true and *Include Method* is true the method parameter types are also included in key generation. This is broken out separately from the *Include Method* option because of the additional runtime cost. [http://java.sun.com/j2se/1.5.0/docs/api/java/lang/reflect/Method.html#getParameterTypes() Method.getParameterTypes()] is used for including the parameter type data. This call results in the Class array being cloned on every call resulting in extra CPU and garbage collection costs for every key generated. Consider the following use case:
{{{
@Cacheable(cache="weatherCache")
public Weather getWeather(Long locationId);

@Cacheable(cache="weatherCache")
public Weather getWeather(String zipCode);
}}}

Even with *Include Method* true if both of these methods are called with `null` as the parameter the same cache key would be generated. By setting *Include Parameter Types* to true the parameter types will be included in the key and the collision will be avoided.

= Performance =
Included in the unit tests for the project is the `CacheKeyGeneratorPerformanceTest`. This does some very simple synthetic benchmarking of the included !CacheKeyGenerators. The following results are from running this test on a 2.6GHz Core 2 Duo machine. While the actual key generation rates will vary based on hardware and configurations the ratios between the various key generators should be a good guide for any system.

|| *Cache Key Generator* || *Keys/ms* || *% Increase* ||
|| HashCodeCacheKeyGenerator || 4035.06 || 106.82% ||
|| ListCacheKeyGenerator || 1951.05 || 60.90% ||
|| StringCacheKeyGenerator || 1212.56 || 111.72% ||
|| MessageDigestCacheKeyGenerator (MD5) || 572.73 || 1570.84% ||
|| ReflectionHashCodeCacheKeyGenerator || 34.28 || ||