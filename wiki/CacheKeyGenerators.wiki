#summary Overview of available CacheKeyGenerator implementations
#labels Featured
#sidebar TableOfContents

= Introduction =

Every method invocation advised by @Cacheable or @!TriggersRemove has to have a key generated for use when access the corresponding cache. The [http://ehcache-spring-annotations.googlecode.com/svn/site/1.0.0/apidocs/com/googlecode/ehcache/annotations/key/CacheKeyGenerator.html CacheKeyGenerator] interface defines the API for generating these keys.

= Provided Cache Key Generators =
||*HashCodeCacheKeyGenerator*|| The default key generator. Very similar to [http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html#deepHashCode(java.lang.Object%5B%5D) Arrays.deepHashCode] ||
||*StringCacheKeyGenerator*|| A nice human readable key generator. Simply uses [http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html#deepToString(java.lang.Object%5B%5D) Arrays.deepToString] ||
||*ListCacheKeyGenerator*|| Does a deep inspection converting arrays to Lists and returning an immutable List of the key arguments. Useful if complete assurance is required when doing key comparisons ||
||*MessageDigestCacheKeyGenerator*|| Does the same object graph traversal that HashCodeCacheKeyGenerator does but instead of accumulating the hash code in a long a [http://java.sun.com/j2se/1.5.0/docs/api/java/security/MessageDigest.html MessageDigest] is used. ||
||*ReflectionHashCodeCacheKeyGenerator*|| Does the same object graph traversal than HashCodeCacheKeyGenerator does but uses reflection to generate a hash code for objects that don't implement hashCode ||

== Common Key Generator Configuration ==
All of the included !CacheKeyGenerator implementations extend [http://ehcache-spring-annotations.googlecode.com/svn/site/1.0.0/apidocs/com/googlecode/ehcache/annotations/key/AbstractCacheKeyGenerator.html AbstractCacheKeyGenerator] which provides the following common configuration options.

==== Check for Cycles ====
Default *false*: If true the key generator will track visited objects during recursion and if a cycle is detected handle it correctly. If false the exact behavior is undefined but many of the key generators will fail with StackOverflowError due to infinite recursion.

==== Include Method ====
Default *true*: If true the declaring class, method name and method return type are included in the generated cache key. The effect of this is that keys become scoped to the annotated method. Consider the following method definitions:
{{{
@Cacheable(cache="weatherCache")
public Weather getWeatherById(String locationId);

@Cacheable(cache="weatherCache")
public Weather getWeatherByZip(String zipCode);
}}}

If both of these methods are called with the argument "49931" and the include method property is true different cache keys will be created. If the include method property is false the keys would be the same and could result in a collision if different Weather objects exist for "49931" as the locationId versus "49931" as the zipCode.

==== Include Parameter Types ====
Default *true*: If true and *Include Method* is true the method parameter types are also included in key generation. This is broken out separately from the *Include Method* option because of the additional runtime cost. [http://java.sun.com/j2se/1.5.0/docs/api/java/lang/reflect/Method.html#getParameterTypes() Method.getParameterTypes()] is used for including the parameter type data. This call results in the Class array being cloned on every call resulting in extra CPU and garbage collection costs for every key generated. Consider the following use case:
{{{
@Cacheable(cache="weatherCache")
public Weather getWeather(Long locationId);

@Cacheable(cache="weatherCache")
public Weather getWeather(String zipCode);
}}}

Even with *Include Method* true if both of these methods are called with `null` as the parameter the same cache key would be generated. By setting *Include Parameter Types* to true the parameter types will be included in the key and the collision will be avoided.

= Performance =
Included in the unit tests for the project is the `CacheKeyGeneratorPerformanceTest`. This does some very simple synthetic benchmarking of the included !CacheKeyGenerators. The following results are from running this test on a 2.6GHz Core 2 Duo machine. While the actual key generation rates will vary based on hardware and configurations the ratios between the various key generators should be a good guide for any system.

|| *Cache Key Generator* || *Keys/ms* || *% Increase* ||
|| HashCodeCacheKeyGenerator || 4035.06 || 106.82% ||
|| ListCacheKeyGenerator || 1951.05 || 60.90% ||
|| StringCacheKeyGenerator || 1212.56 || 111.72% ||
|| MessageDigestCacheKeyGenerator_"MD5" || 572.73 || 1570.84% ||
|| ReflectionHashCodeCacheKeyGenerator || 34.28 || ||


== !ListCacheKeyGenerator ==
Does a deep inspection converting arrays to Lists and returning an immutable, Serializable, List of the arguments as the key. Useful if complete equality assurance is required when doing key comparisons as the original arguments are used for every key comparison.

 * This key generated depends on all of the method arguments correctly implementing the hashCode and equals methods. The only exception is for arrays as these are handled element by element.
 * This generator creates keys quickly but comparing keys is much slower as the Lists have to be iterated every time hashCode and equals is called.
 * Keys generated should be consistent across JVM restarts or between JVM instances as long as all objects used as method arguments implement toString such that the object's identity is included.

The key following example call with the default options:
{{{
//@Cacheable annotated method
dao.getWeather("49931");
}}}
Would generate a key that would pass hashCode and equals comparisons with:
{{{
Arrays.asList(
    x.y.z.WeatherDaoImpl.class,
    "getWeather",
    x.y.z.Weather.class,
    Arrays.asList(String.class),
    Arrays.asList("49931"));
}}}

== !MessageDigestCacheKeyGenerator ==
Does the same object graph traversal that [#HashCodeCacheKeyGenerator HashCodeCacheKeyGenerator] does but instead of accumulating the hash code in a long a [http://java.sun.com/j2se/1.5.0/docs/api/java/security/MessageDigest.html MessageDigest] is used. This results in a much larger key space and the use of a cryptographic hashing function for better key distribution.

 * This key generated depends on all of the method arguments correctly implementing the hashCode method. The only exception is for arrays, Collections and Maps as these are handled element by element.
 * Any supported MessageDigest algorithm can be used. The result is always a URL safe base64 encoding of the hash byte array.
 * The default digest algorithm is SHA-1
 * This key generator is the second slowest included in the library.
 * Keys generated should be consistent across JVM restarts or between JVM instances as long as all objects used as method arguments correctly implement hashCode.

The key `"FKeW4z_I5_yc_z9J98GmaM4aWSU"` would be generated for the following example call with the default options:
{{{
//@Cacheable annotated method
dao.getWeather("49931");
}}}

== !ReflectionHashCodeCacheKeyGenerator ==
Does the same object graph traversal than [#HashCodeCacheKeyGenerator HashCodeCacheKeyGenerator] does but uses reflection to generate a hash code for objects that don't implement hashCode. For each object visited reflection is used to find the hashCode method. If the hashCode method only exists on the base Object reflection is then used to recurse on every non-transient, non-static field in the object.

 * This key generator is the slowest included in the library.
 * Keys generated should be consistent across JVM restarts or between JVM instances as long as all objects used as method arguments correctly implement hashCode.

The key `-78777307802668` would be generated for the following example call with the default options:
{{{
private static class WeatherId {
    private final String id;

    public WeatherId(String id) {
        this.id = id;
    }
}

//@Cacheable annotated method
dao.getWeather(new WeatherId("49931"));
}}}

Note in the example !WeatherId does not implement hashCode but a consistent key is still generated.