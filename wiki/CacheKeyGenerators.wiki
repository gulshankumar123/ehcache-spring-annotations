#summary Overview of available CacheKeyGenerator implementations
#labels Featured

= Introduction =

Every method invocation advised by @Cacheable or @!TriggersRemove has to have a key generated for use when access the corresponding cache. The [http://ehcache-spring-annotations.googlecode.com/svn/site/1.0.0/apidocs/com/googlecode/ehcache/annotations/key/CacheKeyGenerator.html CacheKeyGenerator] interface defines the API for generating these keys.

= Provided Cache Key Generators =
||*[#HashCodeCacheKeyGenerator HashCodeCacheKeyGenerator]*|| The default key generator. Very similar to [http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html#deepHashCode(java.lang.Object%5B%5D) Arrays.deepHashCode] ||
||*[#StringCacheKeyGenerator StringCacheKeyGenerator]*|| A nice human readable key generator. Simply uses [http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html#deepToString(java.lang.Object%5B%5D) Arrays.deepToString] ||
||*[#ListCacheKeyGenerator ListCacheKeyGenerator]*|| Does a deep inspection converting arrays to Lists and returning an immutable List of the key arguments. Useful if complete assurance is required when doing key comparisons ||
||*[#MessageDigestCacheKeyGenerator MessageDigestCacheKeyGenerator]*|| Does the same object graph traversal that [#HashCodeCacheKeyGenerator HashCodeCacheKeyGenerator] does but instead of accumulating the hash code in a long a [http://java.sun.com/j2se/1.5.0/docs/api/java/security/MessageDigest.html MessageDigest] is used. ||
||*[#ReflectionHashCodeCacheKeyGenerator ReflectionHashCodeCacheKeyGenerator]*|| Does the same object graph traversal than !HashCodeCacheKeyGenerator does but uses reflection to generate a hash code for objects that don't implement hashCode ||

== Common Key Generator Configuration ==
All of the included !CacheKeyGenerator implementations extend [http://ehcache-spring-annotations.googlecode.com/svn/site/1.0.0/apidocs/com/googlecode/ehcache/annotations/key/AbstractCacheKeyGenerator.html AbstractCacheKeyGenerator] which provides the following common configuration options.

==== Check for Cycles ====
Default *false*: If true the key generator will track visited objects during recursion and if a cycle is detected handle it correctly. If false the exact behavior is undefined but many of the key generators will fail with StackOverflowError due to infinite recursion.

==== Include Method ====
Default *true*: If true the declaring class, method name and method return type are included in the generated cache key. The effect of this is that keys become scoped to the annotated method. Consider the following method definitions:
{{{
@Cacheable(cache="weatherCache")
public Weather getWeatherById(String locationId);

@Cacheable(cache="weatherCache")
public Weather getWeatherByZip(String zipCode);
}}}

If both of these methods are called with the argument "49931" and the include method property is true different cache keys will be created. If the include method property is false the keys would be the same and could result in a collision if different Weather objects exist for "49931" as the locationId versus "49931" as the zipCode.

==== Include Parameter Types ====
Default *true*: If true and *Include Method* is true the method parameter types are also included in key generation. This is broken out separately from the *Include Method* option because of the additional runtime cost. [http://java.sun.com/j2se/1.5.0/docs/api/java/lang/reflect/Method.html#getParameterTypes() Method.getParameterTypes()] is used for including the parameter type data. This call results in the Class array being cloned on every call resulting in extra CPU and garbage collection costs for every key generated. Consider the following use case:
{{{
@Cacheable(cache="weatherCache")
public Weather getWeather(Long locationId);

@Cacheable(cache="weatherCache")
public Weather getWeather(String zipCode);
}}}

Even with *Include Method* true if both of these methods are called with `null` as the parameter the same cache key would be generated. By setting *Include Parameter Types* to true the parameter types will be included in the key and the collision will be avoided.

== !HashCodeCacheKeyGenerator ==
Generates a simple 64bit hash code based on the method arguments. The hash code generation algorithm is very close to [http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html#deepHashCode(java.lang.Object%5B%5D) Arrays.deepHashCode] with the only major differences being the use of a long instead of an int and that Collections and Maps are iterated over.

 * This key generated depends on all of the method arguments correctly implementing the hashCode method. The only exception is for arrays, Collections and Maps as these are handled element by element.
 * This is the fastest key generator included in the library.
 * With only 64 bits of key space there some potential for key collisions, especially since the Java hash code implementation is not a cryptographic hash code.
 * Keys generated should be consistent across JVM restarts or between JVM instances as long as all objects used as method arguments correctly implement hashCode.

The key `-78777307802699` would be generated for the following example call with the default options:
{{{
//@Cacheable annotated method
dao.getWeather("49931");
}}}

== !StringCacheKeyGenerator ==
Uses [http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html#deepToString(java.lang.Object%5B%5D) Arrays.deepToString] to generate a generally human readable key.

 * This key generated depends on all of the method arguments correctly implementing the toString method. The only exception is for arrays as these are handled element by element.
 * This is the second fastest key generator included in the library.
 * For arguments that implement toString in such a way that their identity is written out this generator is more collision resistant than the [#HashCodeCacheKeyGenerator HashCodeCacheKeyGenerator]
 * Keys generated should be consistent across JVM restarts or between JVM instances as long as all objects used as method arguments implement toString such that the object's identity is included.

The key `[class x.y.z.WeatherDaoImpl, getWeather class x.y.z.Weather, [class java.lang.String], [49931]]` would be generated for the following example call with the default options:
{{{
//@Cacheable annotated method
dao.getWeather("49931");
}}}

== !ListCacheKeyGenerator ==
Does a deep inspection converting arrays to Lists and returning an immutable, Serializable, List of the arguments as the key. Useful if complete equality assurance is required when doing key comparisons as the original arguments are used for every key comparison.

 * This key generated depends on all of the method arguments correctly implementing the hashCode and equals methods. The only exception is for arrays as these are handled element by element.
 * This generator creates keys quickly but comparing keys is much slower as the Lists have to be iterated every time hashCode and equals is called.
 * Keys generated should be consistent across JVM restarts or between JVM instances as long as all objects used as method arguments implement toString such that the object's identity is included.

The key following example call with the default options:
{{{
//@Cacheable annotated method
dao.getWeather("49931");
}}}
Would generate a key that would pass hashCode and equals comparisons with:
{{{
Arrays.asList(
    x.y.z.WeatherDaoImpl.class,
    "getWeather",
    x.y.z.Weather.class,
    Arrays.asList(String.class),
    Arrays.asList("49931"));
}}}

== !MessageDigestCacheKeyGenerator ==
Does the same object graph traversal that [#HashCodeCacheKeyGenerator HashCodeCacheKeyGenerator] does but instead of accumulating the hash code in a long a [http://java.sun.com/j2se/1.5.0/docs/api/java/security/MessageDigest.html MessageDigest] is used.


== !ReflectionHashCodeCacheKeyGenerator ==
Does the same object graph traversal than [#HashCodeCacheKeyGenerator HashCodeCacheKeyGenerator] does but uses reflection to generate a hash code for objects that don't implement hashCode.